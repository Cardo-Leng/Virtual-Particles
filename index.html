<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI ç²’å­äº¤äº’ç³»ç»Ÿ v4.3</title>
    
    <style>
        /* å…¨å±€æ ·å¼ï¼šç¦æ­¢é•¿æŒ‰é€‰ä¸­ï¼Œé˜²æ­¢æ‰‹æœºè¯¯è§¦ */
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', Helvetica, sans-serif; user-select: none; -webkit-user-select: none; touch-action: none; }
        
        /* è§†é¢‘åé¦ˆçª—å£ (æ‰‹æœºä¸Šç¼©å°å¹¶åŠé€æ˜ï¼Œé¿å…é®æŒ¡) */
        #video-container {
            position: absolute; bottom: 15px; left: 15px;
            width: 100px; height: 133px; /* 3:4 æ¯”ä¾‹ */
            border-radius: 10px; overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.15);
            z-index: 10; transform: scaleX(-1); pointer-events: none;
            opacity: 0.8;
        }
        video { width: 100%; height: 100%; object-fit: cover; }

        /* UI æ§åˆ¶é¢æ¿ (é€‚é…çª„å±æ‰‹æœº) */
        #ui-container {
            position: absolute; top: 10px; right: 10px;
            background: rgba(20, 20, 20, 0.65); backdrop-filter: blur(10px);
            padding: 15px; border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white; z-index: 100; display: flex; flex-direction: column;
            gap: 12px; width: 160px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }

        h3 { margin: 0; font-size: 11px; font-weight: 600; color: #888; text-transform: uppercase; letter-spacing: 0.5px; }

        /* æŒ‰é’®ç½‘æ ¼ */
        .grid-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        button {
            background: rgba(255, 255, 255, 0.1); border: none; color: white;
            padding: 8px; border-radius: 6px; font-size: 11px; cursor: pointer;
            transition: background 0.2s;
        }
        button:hover { background: rgba(255, 255, 255, 0.2); }
        button.active { background: #00d2ff; color: #000; font-weight: 700; box-shadow: 0 0 10px rgba(0, 210, 255, 0.3); }

        /* å¼€å…³æ ·å¼ */
        .switch-container { display: flex; justify-content: space-between; align-items: center; font-size: 11px; }
        .toggle-switch { position: relative; display: inline-block; width: 36px; height: 20px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #444; transition: .4s; border-radius: 20px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #30d158; }
        input:checked + .slider:before { transform: translateX(16px); }

        /* é¢œè‰²é€‰æ‹©å™¨ */
        .color-wrapper { display: flex; align-items: center; justify-content: space-between; font-size: 11px; }
        input[type="color"] { -webkit-appearance: none; appearance: none; border: none; width: 24px; height: 24px; border-radius: 50%; background: none; padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 2px solid white; border-radius: 50%; }

        /* çŠ¶æ€æ–‡å­— */
        #status { font-size: 10px; color: #00d2ff; text-align: center; margin-top: 5px; white-space: nowrap; }

        /* åŠ è½½æç¤º */
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00d2ff; font-size: 14px; z-index: 200; pointer-events: none;
            text-align: center; line-height: 1.6;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        ç³»ç»Ÿåˆå§‹åŒ–ä¸­...<br>
        <span style="font-size:12px; color:#aaa">è¯·å…è®¸æ‘„åƒå¤´æƒé™</span><br>
        <span style="font-size:11px; color:#666">(è‹¥é»‘å±è¯·åˆ·æ–°é¡µé¢)</span>
    </div>

    <div id="ui-container">
        <h3>æ§åˆ¶é€‰é¡¹</h3>
        <div class="switch-container">
            <span>è‡ªåŠ¨æ—‹è½¬</span>
            <label class="toggle-switch">
                <input type="checkbox" id="rotationToggle" checked>
                <span class="slider"></span>
            </label>
        </div>
        
        <h3>æ¨¡å‹åˆ‡æ¢</h3>
        <div class="grid-buttons">
            <button onclick="setShape('hand')" class="active" id="btn-hand" style="grid-column: span 2;">ğŸ– åŠ¨æ€åŒäººæ‰‹åŠ¿</button>
            <button onclick="setShape('heart')" id="btn-heart">â¤ï¸ çˆ±å¿ƒ</button>
            <button onclick="setShape('planet')" id="btn-planet">ğŸŒ åœ°çƒ</button>
            <button onclick="setShape('saturn')" id="btn-saturn">ğŸª åœŸæ˜Ÿ</button>
            <button onclick="setShape('flower')" id="btn-flower">ğŸŒ¸ èŠ±æœµ</button>
        </div>

        <div class="color-wrapper">
            <span>ç²’å­é¢œè‰²</span>
            <input type="color" id="colorPicker" value="#00d2ff">
        </div>
        <div id="status">ç­‰å¾…æ‘„åƒå¤´...</div>
    </div>

    <div id="video-container">
        <video id="input_video" playsinline webkit-playsinline muted autoplay></video>
    </div>

    <script>
        // ================= é…ç½®ä¸å¸¸é‡ =================
        const MAX_HANDS = 2; // æ”¯æŒåŒæ‰‹
        // ä¸ºäº†æ‰‹æœºæ€§èƒ½å¹³è¡¡ï¼Œç²’å­æ•°è®¾ä¸º 25000 (å¦‚æœæ‰‹æœºå¾ˆæ–°ï¼Œå¯å°è¯•æ”¹å› 35000)
        const TOTAL_PARTICLES = 25000; 
        const PARTICLES_PER_HAND = Math.floor(TOTAL_PARTICLES / MAX_HANDS); 
        
        const HAND_SCALE_BASE = 180; // æ‰‹æŒåŸºç¡€å¤§å°
        const ARM_LENGTH = 400;      // æ‰‹è‡‚é•¿åº¦
        
        let scene, camera, renderer, particles, geometry, material;
        let targetPositions = new Float32Array(TOTAL_PARTICLES * 3);
        let currentPositions = new Float32Array(TOTAL_PARTICLES * 3);
        
        // çŠ¶æ€å˜é‡
        let handScales = new Float32Array(MAX_HANDS).fill(0); // æ¯åªæ‰‹çš„ç‹¬ç«‹ç¼©æ”¾
        let currentShape = 'hand'; 
        let multiHandLandmarks = []; 
        let targetColor = new THREE.Color(0x00d2ff);
        let isAutoRotation = true;
        
        let handOpenFactor = 0; // é™æ€æ¨¡å‹ç¼©æ”¾å› å­
        let mainHandRotation = { x:0, y:0, z:0 }; // é™æ€æ¨¡å‹æ—‹è½¬è§’åº¦

        // éª¨éª¼è¿æ¥å®šä¹‰
        const HAND_CONNECTIONS = [
            [0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],
            [0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],
            [0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17]
        ];

        // ================= Three.js åˆå§‹åŒ– =================
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.z = 500; // é€‚é…æ‰‹æœºç«–å±ï¼Œæ‹‰è¿œä¸€ç‚¹

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            // é™åˆ¶åƒç´ æ¯”ï¼Œé˜²æ­¢é«˜åˆ†å±æ‰‹æœºè¿‡çƒ­
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            document.body.appendChild(renderer.domElement);

            geometry = new THREE.BufferGeometry();
            for (let i = 0; i < TOTAL_PARTICLES * 3; i++) {
                currentPositions[i] = (Math.random() - 0.5) * 500;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));

            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
            material = new THREE.PointsMaterial({
                size: 4, // ç²’å­å¤§å°
                color: targetColor,
                map: sprite,
                sizeAttenuation: true,
                alphaTest: 0.5,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            setShape('hand'); // é»˜è®¤å¯åŠ¨æ‰‹æŒæ¨¡å¼
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        // ================= é™æ€å½¢çŠ¶è®¡ç®— (é«˜çµæ•åº¦ç‰ˆ) =================
        function calculateStaticShape(type) {
            const RENDER_SIZE = 180;
            const positions = [];
            for (let i = 0; i < TOTAL_PARTICLES; i++) {
                let x=0, y=0, z=0;
                if(type === 'heart') {
                     let t = Math.random() * Math.PI * 2;
                     x = 16 * Math.pow(Math.sin(t), 3);
                     y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                     x *= 13; // æ”¾å¤§å€æ•°
                     y *= 13; 
                     z = (Math.random() - 0.5) * 80;
                     // å†…éƒ¨å¡«å……
                     if (Math.random() < 0.5) { const s = Math.random(); x*=s; y*=s; z*=s; }
                     x += (Math.random()-0.5)*15; y += (Math.random()-0.5)*15;
                } else if(type !== 'hand') {
                     // åŸºç¡€çƒä½“ç”Ÿæˆ
                     const r = RENDER_SIZE * Math.cbrt(Math.random());
                     const theta = Math.random() * Math.PI * 2;
                     const phi = Math.acos(2 * Math.random() - 1);
                     x = r * Math.sin(phi) * Math.cos(theta);
                     y = r * Math.sin(phi) * Math.sin(theta);
                     z = r * Math.cos(phi);
                     
                     if (type === 'saturn') {
                         if (Math.random() > 0.6) {
                            const rRing = (RENDER_SIZE*1.2) + Math.random()*80;
                            const tRing = Math.random()*Math.PI*2;
                            x = rRing * Math.cos(tRing); z = rRing * Math.sin(tRing); y = (Math.random()-0.5)*5;
                         }
                     } else if (type === 'flower') {
                         const rBase = RENDER_SIZE * Math.sqrt(Math.random());
                         const fTheta = Math.random() * Math.PI * 2;
                         const k = 5;
                         const fR = rBase * Math.cos(k * fTheta) + RENDER_SIZE * 0.4;
                         x = fR * Math.cos(fTheta); y = fR * Math.sin(fTheta); 
                         z = (Math.random() - 0.5) * 80 * Math.cos(k*fTheta);
                     }
                }
                targetPositions[i * 3] = x; 
                targetPositions[i * 3 + 1] = y; 
                targetPositions[i * 3 + 2] = z;
            }
        }

        function setShape(shape) {
            currentShape = shape;
            document.querySelectorAll('.grid-buttons button').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${shape}`).classList.add('active');
            
            if (shape !== 'hand') {
                calculateStaticShape(shape); 
                document.getElementById('rotationToggle').disabled = false;
                particles.rotation.set(0,0,0);
            } else {
                document.getElementById('rotationToggle').disabled = true;
                particles.rotation.set(0,0,0);
            }
        }

        // ================= å•åªæ‰‹æŒç²’å­ç”Ÿæˆ =================
        function updateSingleHandParticles(landmarks, handIndex) {
            const startIndex = handIndex * PARTICLES_PER_HAND;
            const endIndex = startIndex + PARTICLES_PER_HAND;
            // 70% ç²’å­ç”¨äºæ‰‹æŒï¼Œ30% ç”¨äºæ‰‹è‡‚
            const handParticleCount = Math.floor(PARTICLES_PER_HAND * 0.7);
            const handEndIndex = startIndex + handParticleCount;

            let pIndex = startIndex;
            const particlesPerBone = Math.floor(handParticleCount / HAND_CONNECTIONS.length);

            // 1. ç”Ÿæˆæ‰‹æŒéª¨éª¼
            HAND_CONNECTIONS.forEach(pair => {
                const start = landmarks[pair[0]];
                const end = landmarks[pair[1]];
                for (let i = 0; i < particlesPerBone; i++) {
                    if (pIndex >= handEndIndex) break;
                    
                    const t = Math.random();
                    // MediaPipe åæ ‡ (0~1) æ˜ å°„åˆ° 3D ç©ºé—´
                    let tx = (0.5 - (start.x + (end.x - start.x) * t)) * HAND_SCALE_BASE * 2.5;
                    let ty = (0.5 - (start.y + (end.y - start.y) * t)) * HAND_SCALE_BASE * 2.5;
                    let tz = -(start.z + (end.z - start.z) * t) * HAND_SCALE_BASE * 2.0;

                    const spread = 8 * (1.0 - t * 0.5);
                    tx += (Math.random() - 0.5) * spread;
                    ty += (Math.random() - 0.5) * spread;
                    tz += (Math.random() - 0.5) * spread;

                    targetPositions[pIndex * 3] = tx;
                    targetPositions[pIndex * 3 + 1] = ty;
                    targetPositions[pIndex * 3 + 2] = tz;
                    pIndex++;
                }
            });

            // 2. ç”Ÿæˆæ‰‹è‡‚æ‹–å°¾
            const wrist = landmarks[0];
            const middleMCP = landmarks[9];
            // è®¡ç®—æ‰‹è‡‚æ–¹å‘
            let dx = wrist.x - middleMCP.x;
            let dy = wrist.y - middleMCP.y;
            let dz = wrist.z - middleMCP.z;
            const len = Math.sqrt(dx*dx + dy*dy + dz*dz);
            dx /= len; dy /= len; dz /= len;

            const wristX = (0.5 - wrist.x) * HAND_SCALE_BASE * 2.5;
            const wristY = (0.5 - wrist.y) * HAND_SCALE_BASE * 2.5;
            const wristZ = -wrist.z * HAND_SCALE_BASE * 2.0;

            for (let i = handEndIndex; i < endIndex; i++) {
                const t = Math.random();
                const dist = t * ARM_LENGTH;

                let tx = wristX + (-dx) * dist;
                let ty = wristY + (-dy) * dist;
                let tz = wristZ + (-dz) * dist;

                // è·ç¦»è¶Šè¿œï¼Œæ•£å¸ƒè¶Šå¤§ (å¹³æ–¹å¢é•¿)
                const armSpread = 15 + Math.pow(t, 2) * 100;

                tx += (Math.random() - 0.5) * armSpread;
                ty += (Math.random() - 0.5) * armSpread;
                tz += (Math.random() - 0.5) * armSpread;

                targetPositions[i * 3] = tx;
                targetPositions[i * 3 + 1] = ty;
                targetPositions[i * 3 + 2] = tz;
            }
        }

        // ================= åŠ¨ç”»ä¸»å¾ªç¯ =================
        function animate() {
            requestAnimationFrame(animate);
            material.color.lerp(targetColor, 0.05);

            // --- A. åŠ¨æ€æ‰‹æŒæ¨¡å¼ ---
            if (currentShape === 'hand') {
                for (let i = 0; i < MAX_HANDS; i++) {
                    if (i < multiHandLandmarks.length) {
                        const landmarks = multiHandLandmarks[i];
                        updateSingleHandParticles(landmarks, i);
                        // æ ¹æ®æ‰‹è…• Z æ·±åº¦è®¡ç®—ç¼©æ”¾
                        let s = (landmarks[0].z + 0.2) * 3.0;
                        handScales[i] = THREE.MathUtils.clamp(s, 0.4, 2.5);
                    } else {
                        // å¦‚æœæ‰‹æ¶ˆå¤±ï¼Œç¼©æ”¾å½’é›¶
                        handScales[i] = THREE.MathUtils.lerp(handScales[i], 0, 0.1); 
                    }
                }
                particles.rotation.set(0,0,0);
            } 
            // --- B. é™æ€å½¢çŠ¶æ¨¡å¼ ---
            else {
                let hasHand = multiHandLandmarks.length > 0;
                
                if (isAutoRotation) {
                    particles.rotation.y += 0.002;
                    particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, 0, 0.05);
                    particles.rotation.z = THREE.MathUtils.lerp(particles.rotation.z, 0, 0.05);
                } else if (hasHand) {
                    // è·Ÿéšä¸»æ‰‹æ—‹è½¬
                    particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, mainHandRotation.x, 0.1);
                    particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, mainHandRotation.y, 0.1);
                    particles.rotation.z = THREE.MathUtils.lerp(particles.rotation.z, mainHandRotation.z, 0.1);
                }
            }

            // --- C. ç²’å­ä½ç½®æ›´æ–° ---
            const positions = geometry.attributes.position.array;
            
            for (let i = 0; i < TOTAL_PARTICLES; i++) {
                // è®¡ç®—å½“å‰ç²’å­å±äºå“ªåªæ‰‹ (0, 1...)
                const handIndex = Math.floor(i / PARTICLES_PER_HAND);
                let effectiveScale = 1.0;
                
                if (currentShape === 'hand') {
                    effectiveScale = handScales[handIndex];
                } else {
                    // é™æ€æ¨¡å¼ï¼šé«˜çµæ•åº¦ç¼©æ”¾
                    if (multiHandLandmarks.length > 0) {
                        // 0.6 + factor * 2.2 -> æ‰‹å¼ å¼€æ—¶å˜å¾—å¾ˆå¤§
                        effectiveScale = 0.6 + (handOpenFactor * 2.2);
                    } else {
                        // è‡ªåŠ¨å‘¼å¸
                        const time = Date.now() * 0.001;
                        effectiveScale = 0.7 + Math.sin(time) * 0.2;
                    }
                }

                const px = positions[i*3], py = positions[i*3+1], pz = positions[i*3+2];
                const tx = targetPositions[i*3], ty = targetPositions[i*3+1], tz = targetPositions[i*3+2];
                
                // æ‰‹æŒæ¨¡å¼ç§»åŠ¨å¿«ä¸€ç‚¹(0.2)ï¼Œé™æ€æ¨¡å¼æ…¢ä¸€ç‚¹(0.06)
                const speed = currentShape === 'hand' ? 0.2 : 0.06;

                positions[i*3]   += (tx * effectiveScale - px) * speed;
                positions[i*3+1] += (ty * effectiveScale - py) * speed;
                positions[i*3+2] += (tz * effectiveScale - pz) * speed;
            }

            geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ================= MediaPipe é€»è¾‘ =================
        const statusElement = document.getElementById('status');

        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            
            multiHandLandmarks = results.multiHandLandmarks || [];

            // è®¡ç®—é™æ€æ¨¡å¼æ‰€éœ€çš„é€šç”¨å‚æ•° (ä½¿ç”¨ç¬¬ä¸€åªæ‰‹)
            if (multiHandLandmarks.length > 0) {
                const primaryHand = multiHandLandmarks[0];
                const palm = primaryHand[0];
                
                // è®¡ç®—å¼ åˆç¨‹åº¦
                let totalDist = 0;
                [4, 8, 12, 16, 20].forEach(idx => {
                    const tip = primaryHand[idx];
                    totalDist += Math.sqrt(Math.pow(tip.x - palm.x, 2) + Math.pow(tip.y - palm.y, 2));
                });
                
                let rawFactor = (totalDist / 5 - 0.1) * 3.5;
                handOpenFactor = Math.max(0, Math.min(1, rawFactor));

                // è®¡ç®—æ—‹è½¬è§’åº¦
                if (!isAutoRotation) {
                    const wrist = primaryHand[0];
                    const mid = primaryHand[9];
                    const dx = mid.x - wrist.x;
                    const dy = mid.y - wrist.y;
                    
                    mainHandRotation.z = (Math.atan2(dy, dx) + Math.PI / 2);
                    mainHandRotation.x = (primaryHand[12].z - wrist.z) * 3.0;
                    mainHandRotation.y = (primaryHand[17].z - primaryHand[5].z) * 3.0;
                }
            } else {
                handOpenFactor = 0;
            }

            // æ›´æ–° UI æ–‡æœ¬
            if (multiHandLandmarks.length > 0) {
                const count = multiHandLandmarks.length;
                if (currentShape === 'hand') {
                    statusElement.innerText = `è¿½è¸ªä¸­: ${count} åªæ‰‹ | ç‹¬ç«‹æ§åˆ¶`;
                    statusElement.style.color = "#30d158";
                } else {
                    if(!isAutoRotation) {
                        statusElement.innerText = `é™æ€æ¨¡å¼ | é«˜çµæ•ç¼©æ”¾ | æ‰‹åŠ¿æ—‹è½¬`;
                    } else {
                        statusElement.innerText = `é™æ€æ¨¡å¼ | é«˜çµæ•ç¼©æ”¾ | è‡ªåŠ¨æ—‹è½¬`;
                    }
                    statusElement.style.color = "#00d2ff";
                }
            } else {
                statusElement.innerText = "æœªæ£€æµ‹åˆ°æ‰‹åŠ¿ | è‡ªåŠ¨æ¼”ç¤º";
                statusElement.style.color = "#aaa";
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: MAX_HANDS, 
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);
        
        // æ‰‹æœºæ‘„åƒå¤´å¯åŠ¨é€»è¾‘ (æ— å›ºå®šåˆ†è¾¨ç‡ï¼Œè‡ªé€‚åº”)
        const videoElement = document.getElementById('input_video');
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            // ä¸è®¾ç½® width/height ä»¥å…è®¸è‡ªé€‚åº”
        });
        
        cameraUtils.start().catch(err => {
            console.error(err);
            alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥: " + err.message + "\nè¯·ç¡®ä¿ä½¿ç”¨ HTTPS åè®®è®¿é—®ï¼Œæˆ–æ›´æ¢æµè§ˆå™¨ã€‚");
        });
        
        // UI äº‹ä»¶
        document.getElementById('rotationToggle').addEventListener('change', (e)=>{isAutoRotation=e.target.checked;});
        document.getElementById('colorPicker').addEventListener('input', (e)=>{targetColor.set(e.target.value);});

        // å¯åŠ¨
        initThree();
    </script>
</body>
</html>

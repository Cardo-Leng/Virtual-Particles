<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI ç²’å­äº¤äº’ç³»ç»Ÿ v4.4 (åŒç«¯é€‚é…ç‰ˆ)</title>
    
    <style>
        /* å…¨å±€æ ·å¼ */
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', Helvetica, sans-serif; user-select: none; -webkit-user-select: none; touch-action: none; }
        
        /* ================= å“åº”å¼å¸ƒå±€æ ¸å¿ƒ ================= */
        
        /* 1. é»˜è®¤æ ·å¼ (ä»¥ç”µè„‘ç«¯ä½“éªŒä¸ºä¸») */
        #video-container {
            position: absolute; bottom: 20px; left: 20px;
            /* ç”µè„‘ç«¯ï¼šå¤§å°ºå¯¸ï¼Œæ¨ªå± 4:3 */
            width: 320px; height: 240px; 
            border-radius: 12px; overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 10; transform: scaleX(-1); pointer-events: none;
            opacity: 0.9;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        
        #ui-container {
            position: absolute; top: 20px; right: 20px;
            background: rgba(20, 20, 20, 0.75); backdrop-filter: blur(12px);
            padding: 20px; border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white; z-index: 100; display: flex; flex-direction: column;
            gap: 15px; width: 220px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }

        /* 2. æ‰‹æœºç«¯é€‚é… (å±å¹•å®½åº¦å°äº 768px æ—¶ç”Ÿæ•ˆ) */
        @media (max-width: 768px) {
            #video-container {
                bottom: 15px; left: 15px;
                /* æ‰‹æœºç«¯ï¼šå°å°ºå¯¸ï¼Œç«–å± 3:4 */
                width: 100px; height: 133px; 
                opacity: 0.8;
                border: 2px solid rgba(255, 255, 255, 0.15);
            }

            #ui-container {
                top: 10px; right: 10px;
                padding: 15px; width: 150px; /* å˜çª„ */
                gap: 10px;
            }
            
            /* è°ƒæ•´æ‰‹æœºä¸Šçš„å­—ä½“å¤§å° */
            h3 { font-size: 11px; }
            button { padding: 8px; font-size: 11px; }
            .switch-container, .color-wrapper { font-size: 11px; }
        }

        /* ================= é€šç”¨æ ·å¼ ================= */
        video { width: 100%; height: 100%; object-fit: cover; }

        h3 { margin: 0; font-size: 12px; font-weight: 600; color: #888; text-transform: uppercase; letter-spacing: 0.5px; }

        .grid-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        button {
            background: rgba(255, 255, 255, 0.1); border: none; color: white;
            padding: 10px; border-radius: 8px; font-size: 12px; cursor: pointer;
            transition: background 0.2s;
        }
        button:hover { background: rgba(255, 255, 255, 0.2); }
        button.active { background: #00d2ff; color: #000; font-weight: 700; box-shadow: 0 0 10px rgba(0, 210, 255, 0.3); }

        .switch-container { display: flex; justify-content: space-between; align-items: center; font-size: 12px; }
        .toggle-switch { position: relative; display: inline-block; width: 36px; height: 20px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #444; transition: .4s; border-radius: 20px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #30d158; }
        input:checked + .slider:before { transform: translateX(16px); }

        .color-wrapper { display: flex; align-items: center; justify-content: space-between; font-size: 12px; }
        input[type="color"] { -webkit-appearance: none; appearance: none; border: none; width: 24px; height: 24px; border-radius: 50%; background: none; padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 2px solid white; border-radius: 50%; }

        #status { font-size: 10px; color: #00d2ff; text-align: center; margin-top: 5px; white-space: nowrap; }

        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00d2ff; font-size: 14px; z-index: 200; pointer-events: none;
            text-align: center; line-height: 1.6;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        ç³»ç»Ÿåˆå§‹åŒ–ä¸­...<br>
        <span style="font-size:12px; color:#aaa">è¯·å…è®¸æ‘„åƒå¤´æƒé™</span><br>
        <span style="font-size:11px; color:#666">(è‹¥é»‘å±è¯·åˆ·æ–°é¡µé¢)</span>
    </div>

    <div id="ui-container">
        <h3>æ§åˆ¶é€‰é¡¹</h3>
        <div class="switch-container">
            <span>è‡ªåŠ¨æ—‹è½¬</span>
            <label class="toggle-switch">
                <input type="checkbox" id="rotationToggle" checked>
                <span class="slider"></span>
            </label>
        </div>
        
        <h3>æ¨¡å‹åˆ‡æ¢</h3>
        <div class="grid-buttons">
            <button onclick="setShape('hand')" class="active" id="btn-hand" style="grid-column: span 2;">ğŸ– åŠ¨æ€åŒäººæ‰‹åŠ¿</button>
            <button onclick="setShape('heart')" id="btn-heart">â¤ï¸ çˆ±å¿ƒ</button>
            <button onclick="setShape('planet')" id="btn-planet">ğŸŒ åœ°çƒ</button>
            <button onclick="setShape('saturn')" id="btn-saturn">ğŸª åœŸæ˜Ÿ</button>
            <button onclick="setShape('flower')" id="btn-flower">ğŸŒ¸ èŠ±æœµ</button>
        </div>

        <div class="color-wrapper">
            <span>ç²’å­é¢œè‰²</span>
            <input type="color" id="colorPicker" value="#00d2ff">
        </div>
        <div id="status">ç­‰å¾…æ‘„åƒå¤´...</div>
    </div>

    <div id="video-container">
        <video id="input_video" playsinline webkit-playsinline muted autoplay></video>
    </div>

    <script>
        // ================= é…ç½®ä¸å¸¸é‡ =================
        const MAX_HANDS = 2; 
        
        // åŠ¨æ€æ£€æµ‹ï¼šå¦‚æœæ˜¯ç”µè„‘ï¼Œç²’å­å¤šä¸€ç‚¹(40000)ï¼›å¦‚æœæ˜¯æ‰‹æœºï¼Œç²’å­å°‘ä¸€ç‚¹(25000)
        const isMobile = window.innerWidth < 768;
        const TOTAL_PARTICLES = isMobile ? 25000 : 40000; 
        
        const PARTICLES_PER_HAND = Math.floor(TOTAL_PARTICLES / MAX_HANDS); 
        const HAND_SCALE_BASE = 180; 
        const ARM_LENGTH = 400;      
        
        let scene, camera, renderer, particles, geometry, material;
        let targetPositions = new Float32Array(TOTAL_PARTICLES * 3);
        let currentPositions = new Float32Array(TOTAL_PARTICLES * 3);
        
        let handScales = new Float32Array(MAX_HANDS).fill(0); 
        let currentShape = 'hand'; 
        let multiHandLandmarks = []; 
        let targetColor = new THREE.Color(0x00d2ff);
        let isAutoRotation = true;
        let handOpenFactor = 0; 
        let mainHandRotation = { x:0, y:0, z:0 }; 

        const HAND_CONNECTIONS = [
            [0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],
            [0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],
            [0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17]
        ];

        // ================= Three.js åˆå§‹åŒ– =================
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.z = 500; 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            document.body.appendChild(renderer.domElement);

            geometry = new THREE.BufferGeometry();
            for (let i = 0; i < TOTAL_PARTICLES * 3; i++) {
                currentPositions[i] = (Math.random() - 0.5) * 500;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));

            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
            material = new THREE.PointsMaterial({
                size: 4, 
                color: targetColor,
                map: sprite,
                sizeAttenuation: true,
                alphaTest: 0.5,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            setShape('hand'); 
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        // ================= é™æ€å½¢çŠ¶è®¡ç®— =================
        function calculateStaticShape(type) {
            const RENDER_SIZE = 180;
            const positions = [];
            for (let i = 0; i < TOTAL_PARTICLES; i++) {
                let x=0, y=0, z=0;
                if(type === 'heart') {
                     let t = Math.random() * Math.PI * 2;
                     x = 16 * Math.pow(Math.sin(t), 3);
                     y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                     x *= 13; y *= 13; z = (Math.random() - 0.5) * 80;
                     if (Math.random() < 0.5) { const s = Math.random(); x*=s; y*=s; z*=s; }
                     x += (Math.random()-0.5)*15; y += (Math.random()-0.5)*15;
                } else if(type !== 'hand') {
                     const r = RENDER_SIZE * Math.cbrt(Math.random());
                     const theta = Math.random() * Math.PI * 2;
                     const phi = Math.acos(2 * Math.random() - 1);
                     x = r * Math.sin(phi) * Math.cos(theta);
                     y = r * Math.sin(phi) * Math.sin(theta);
                     z = r * Math.cos(phi);
                     
                     if (type === 'saturn') {
                         if (Math.random() > 0.6) {
                            const rRing = (RENDER_SIZE*1.2) + Math.random()*80;
                            const tRing = Math.random()*Math.PI*2;
                            x = rRing * Math.cos(tRing); z = rRing * Math.sin(tRing); y = (Math.random()-0.5)*5;
                         }
                     } else if (type === 'flower') {
                         const rBase = RENDER_SIZE * Math.sqrt(Math.random());
                         const fTheta = Math.random() * Math.PI * 2;
                         const k = 5;
                         const fR = rBase * Math.cos(k * fTheta) + RENDER_SIZE * 0.4;
                         x = fR * Math.cos(fTheta); y = fR * Math.sin(fTheta); 
                         z = (Math.random() - 0.5) * 80 * Math.cos(k*fTheta);
                     }
                }
                targetPositions[i * 3] = x; 
                targetPositions[i * 3 + 1] = y; 
                targetPositions[i * 3 + 2] = z;
            }
        }

        function setShape(shape) {
            currentShape = shape;
            document.querySelectorAll('.grid-buttons button').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${shape}`).classList.add('active');
            
            if (shape !== 'hand') {
                calculateStaticShape(shape); 
                document.getElementById('rotationToggle').disabled = false;
                particles.rotation.set(0,0,0);
            } else {
                document.getElementById('rotationToggle').disabled = true;
                particles.rotation.set(0,0,0);
            }
        }

        // ================= åŠ¨æ€æ‰‹æŒç”Ÿæˆ =================
        function updateSingleHandParticles(landmarks, handIndex) {
            const startIndex = handIndex * PARTICLES_PER_HAND;
            const endIndex = startIndex + PARTICLES_PER_HAND;
            const handParticleCount = Math.floor(PARTICLES_PER_HAND * 0.7);
            const handEndIndex = startIndex + handParticleCount;

            let pIndex = startIndex;
            const particlesPerBone = Math.floor(handParticleCount / HAND_CONNECTIONS.length);

            HAND_CONNECTIONS.forEach(pair => {
                const start = landmarks[pair[0]];
                const end = landmarks[pair[1]];
                for (let i = 0; i < particlesPerBone; i++) {
                    if (pIndex >= handEndIndex) break;
                    
                    const t = Math.random();
                    let tx = (0.5 - (start.x + (end.x - start.x) * t)) * HAND_SCALE_BASE * 2.5;
                    let ty = (0.5 - (start.y + (end.y - start.y) * t)) * HAND_SCALE_BASE * 2.5;
                    let tz = -(start.z + (end.z - start.z) * t) * HAND_SCALE_BASE * 2.0;

                    const spread = 8 * (1.0 - t * 0.5);
                    tx += (Math.random() - 0.5) * spread; ty += (Math.random() - 0.5) * spread; tz += (Math.random() - 0.5) * spread;

                    targetPositions[pIndex * 3] = tx; targetPositions[pIndex * 3 + 1] = ty; targetPositions[pIndex * 3 + 2] = tz;
                    pIndex++;
                }
            });

            const wrist = landmarks[0];
            const middleMCP = landmarks[9];
            let dx = wrist.x - middleMCP.x; let dy = wrist.y - middleMCP.y; let dz = wrist.z - middleMCP.z;
            const len = Math.sqrt(dx*dx + dy*dy + dz*dz);
            dx /= len; dy /= len; dz /= len;

            const wristX = (0.5 - wrist.x) * HAND_SCALE_BASE * 2.5;
            const wristY = (0.5 - wrist.y) * HAND_SCALE_BASE * 2.5;
            const wristZ = -wrist.z * HAND_SCALE_BASE * 2.0;

            for (let i = handEndIndex; i < endIndex; i++) {
                const t = Math.random();
                const dist = t * ARM_LENGTH;

                let tx = wristX + (-dx) * dist; let ty = wristY + (-dy) * dist; let tz = wristZ + (-dz) * dist;
                const armSpread = 15 + Math.pow(t, 2) * 100;

                tx += (Math.random() - 0.5) * armSpread; ty += (Math.random() - 0.5) * armSpread; tz += (Math.random() - 0.5) * armSpread;

                targetPositions[i * 3] = tx; targetPositions[i * 3 + 1] = ty; targetPositions[i * 3 + 2] = tz;
            }
        }

        // ================= åŠ¨ç”»å¾ªç¯ =================
        function animate() {
            requestAnimationFrame(animate);
            material.color.lerp(targetColor, 0.05);

            if (currentShape === 'hand') {
                for (let i = 0; i < MAX_HANDS; i++) {
                    if (i < multiHandLandmarks.length) {
                        const landmarks = multiHandLandmarks[i];
                        updateSingleHandParticles(landmarks, i);
                        let s = (landmarks[0].z + 0.2) * 3.0;
                        handScales[i] = THREE.MathUtils.clamp(s, 0.4, 2.5);
                    } else {
                        handScales[i] = THREE.MathUtils.lerp(handScales[i], 0, 0.1); 
                    }
                }
                particles.rotation.set(0,0,0);
            } else {
                let hasHand = multiHandLandmarks.length > 0;
                if (isAutoRotation) {
                    particles.rotation.y += 0.002;
                    particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, 0, 0.05);
                    particles.rotation.z = THREE.MathUtils.lerp(particles.rotation.z, 0, 0.05);
                } else if (hasHand) {
                    particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, mainHandRotation.x, 0.1);
                    particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, mainHandRotation.y, 0.1);
                    particles.rotation.z = THREE.MathUtils.lerp(particles.rotation.z, mainHandRotation.z, 0.1);
                }
            }

            const positions = geometry.attributes.position.array;
            for (let i = 0; i < TOTAL_PARTICLES; i++) {
                const handIndex = Math.floor(i / PARTICLES_PER_HAND);
                let effectiveScale = 1.0;
                
                if (currentShape === 'hand') {
                    effectiveScale = handScales[handIndex];
                } else {
                    if (multiHandLandmarks.length > 0) {
                        effectiveScale = 0.6 + (handOpenFactor * 2.2);
                    } else {
                        const time = Date.now() * 0.001;
                        effectiveScale = 0.7 + Math.sin(time) * 0.2;
                    }
                }

                const px = positions[i*3], py = positions[i*3+1], pz = positions[i*3+2];
                const tx = targetPositions[i*3], ty = targetPositions[i*3+1], tz = targetPositions[i*3+2];
                const speed = currentShape === 'hand' ? 0.2 : 0.06;

                positions[i*3]   += (tx * effectiveScale - px) * speed;
                positions[i*3+1] += (ty * effectiveScale - py) * speed;
                positions[i*3+2] += (tz * effectiveScale - pz) * speed;
            }

            geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ================= MediaPipe é€»è¾‘ =================
        const statusElement = document.getElementById('status');

        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            multiHandLandmarks = results.multiHandLandmarks || [];

            if (multiHandLandmarks.length > 0) {
                const primaryHand = multiHandLandmarks[0];
                const palm = primaryHand[0];
                let totalDist = 0;
                [4, 8, 12, 16, 20].forEach(idx => {
                    const tip = primaryHand[idx];
                    totalDist += Math.sqrt(Math.pow(tip.x - palm.x, 2) + Math.pow(tip.y - palm.y, 2));
                });
                
                let rawFactor = (totalDist / 5 - 0.1) * 3.5;
                handOpenFactor = Math.max(0, Math.min(1, rawFactor));

                if (!isAutoRotation) {
                    const wrist = primaryHand[0];
                    const mid = primaryHand[9];
                    const dx = mid.x - wrist.x;
                    const dy = mid.y - wrist.y;
                    
                    mainHandRotation.z = (Math.atan2(dy, dx) + Math.PI / 2);
                    mainHandRotation.x = (primaryHand[12].z - wrist.z) * 3.0;
                    mainHandRotation.y = (primaryHand[17].z - primaryHand[5].z) * 3.0;
                }
            } else {
                handOpenFactor = 0;
            }

            if (multiHandLandmarks.length > 0) {
                const count = multiHandLandmarks.length;
                if (currentShape === 'hand') {
                    statusElement.innerText = `è¿½è¸ªä¸­: ${count} åªæ‰‹ | ç‹¬ç«‹æ§åˆ¶`;
                    statusElement.style.color = "#30d158";
                } else {
                    if(!isAutoRotation) {
                        statusElement.innerText = `é™æ€æ¨¡å¼ | ç¼©æ”¾ | æ‰‹åŠ¿æ—‹è½¬`;
                    } else {
                        statusElement.innerText = `é™æ€æ¨¡å¼ | ç¼©æ”¾ | è‡ªåŠ¨æ—‹è½¬`;
                    }
                    statusElement.style.color = "#00d2ff";
                }
            } else {
                statusElement.innerText = "æœªæ£€æµ‹åˆ°æ‰‹åŠ¿ | è‡ªåŠ¨æ¼”ç¤º";
                statusElement.style.color = "#aaa";
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: MAX_HANDS, 
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);
        
        // ================= æ‘„åƒå¤´è‡ªé€‚åº”é…ç½® =================
        const videoElement = document.getElementById('input_video');
        
        // ã€å…³é”®ã€‘ç”µè„‘ç«¯è¯·æ±‚é«˜åˆ†è¾¨ç‡æ¨ªå±ï¼Œæ‰‹æœºç«¯è¯·æ±‚è‡ªé€‚åº”
        const cameraConfig = {
            onFrame: async () => { await hands.send({image: videoElement}); }
        };

        if (!isMobile) {
            // ç”µè„‘ç«¯ï¼šå¼ºåˆ¶å®½å±
            cameraConfig.width = 1280;
            cameraConfig.height = 720;
        } 
        // æ‰‹æœºç«¯ï¼šä¸è®¾ç½® width/heightï¼Œä½¿ç”¨é»˜è®¤ç«–å±æµ

        const cameraUtils = new Camera(videoElement, cameraConfig);
        
        cameraUtils.start().catch(err => {
            console.error(err);
            alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥: " + err.message);
        });
        
        document.getElementById('rotationToggle').addEventListener('change', (e)=>{isAutoRotation=e.target.checked;});
        document.getElementById('colorPicker').addEventListener('input', (e)=>{targetColor.set(e.target.value);});

        initThree();
    </script>
</body>
</html>
